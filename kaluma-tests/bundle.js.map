{"version":3,"file":"bundle.js","mappings":";;;;;;AAAA,QAAQ,OAAO,EAAE,mBAAO,CAAC,CAAM;AAC/B,QAAQ,SAAS,EAAE,mBAAO,CAAC,CAAQ;AACnC;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,kBAAkB;AAClB,iBAAiB;AACjB,iBAAiB;AACjB,oBAAoB;AACpB;AACA,gBAAgB,eAAe;AAC/B;AACA,6CAA6C,OAAO,GAAG,OAAO;AAC9D;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,aAAa;AACtB,oBAAoB,KAAK,GAAG,KAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY,wBAAwB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,mBAAmB,sDAAsD;AACzE;AACA,gBAAgB,eAAe,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yCAAyC;AACpD,WAAW,yCAAyC;AACpD,WAAW,yCAAyC;AACpD,WAAW;AACX;AACA,eAAe;AACf;AACA,6DAA6D,IAAI;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,oEAAoE;AACpE,oEAAoE;AACpE,kBAAkB;AAClB;AACA,+BAA+B;AAC/B,CAAC;AACD;AACA;AACA;AACA,QAAQ,iBAAiB;AACzB;AACA;AACA,UAAU,eAAe;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,CAAC;AACD;AACA;AACA,cAAc,6BAA6B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C,iBAAiB,mCAAmC;AACpD,cAAc,6BAA6B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrUA;;;;;;ACAA,eAAe,mBAAO,CAAC,CAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,QAAQ;AACrB,eAAe;AACf,gBAAgB;AAChB,YAAY;AACZ,aAAa;AACb,YAAY;AACZ,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,0CAA0C;AAC1C;AACA;AACA,wCAAwC;AACxC,wCAAwC;AACxC,0DAA0D;AAC1D,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC;AACA;AACA,wDAAwD;AACxD,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,6BAA6B;AAC7B;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,eAAe;AAC5B;AACA;AACA,gCAAgC;AAChC;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,+EAA+E;AAC/E,gFAAgF;AAChF,oCAAoC;AACpC,yCAAyC;AACzC;AACA,SAAS;AACT,QAAQ,OAAO;AACf;AACA;AACA;AACA,wCAAwC;AACxC,0EAA0E;AAC1E,0EAA0E;AAC1E,uCAAuC;AACvC,yCAAyC;AACzC,WAAW;AACX;AACA,wCAAwC;AACxC,8EAA8E;AAC9E,8EAA8E;AAC9E,4BAA4B;AAC5B;AACA,yCAAyC;AACzC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;;;;;;;ACpJd;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;ACtBA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,CAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA","sources":["webpack://kaluma-tests/./engine.js","webpack://kaluma-tests/external commonjs \"gpio\"","webpack://kaluma-tests/./node_modules/st7735/index.js","webpack://kaluma-tests/external commonjs \"graphics\"","webpack://kaluma-tests/webpack/bootstrap","webpack://kaluma-tests/./game.js"],"sourcesContent":["const { GPIO } = require(\"gpio\");\r\nconst { ST7735 } = require('st7735');\r\nconst st7735 = new ST7735();\r\n\r\nlet legend = {};\r\nlet img = { data: new Uint8Array(0), width: 0, height: 0 };\r\nlet currentLevel = [];\r\nlet maxTileDim;\r\nlet zOrder = [];\r\nlet solids = [];\r\nlet pushable = {};\r\nlet afterInputFn = () => {};\r\nfunction clear() { currentLevel = []; }\r\n\r\nexports.afterInput = fn => afterInputFn = fn;\r\nexports.setSolids = arr => solids = arr;\r\nexports.setZOrder = arr => zOrder = arr;\r\nexports.setPushables = obj => pushable = obj;\r\n\r\nconst getGrid = exports.getGrid = () => {\r\n\tconst overlaps = {};\r\n\tconst tiles = currentLevel.map(tile => [ `${tile.x},${tile.y}`, tile ]);\r\n\ttiles.forEach( tile => {\r\n\t\tconst [ key, data ] = tile;\r\n\t\tif (key in overlaps) overlaps[key].push(data);\r\n\t\telse overlaps[key] = [data];\r\n\t});\r\n\r\n\treturn overlaps;\r\n}\r\n\r\nconst canMoveToPush = (tile, dx, dy) => {\r\n\tconst grid = getGrid();\r\n\tconst { x, y, type } = tile;\r\n\tconst cellKey = `${x+dx},${y+dy}`;\r\n\r\n\tconst notSolid = !solids.includes(type);\r\n\tconst noMovement = dx === 0 && dy === 0;\r\n\tconst movingToEmpty = !grid[cellKey];\r\n\r\n\tif (notSolid || noMovement || movingToEmpty) {\r\n\t\ttile._x += dx;\r\n\t\ttile._y += dy;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tlet canMove = true;\r\n\r\n\tgrid[cellKey].forEach(cell => {\r\n\t\tconst isSolid = solids.includes(cell.type);\r\n\t\tconst isPushable = (type in pushable) && pushable[type].includes(cell.type);\r\n\r\n\t\tif (isSolid && !isPushable)\r\n\t\tcanMove = false;\r\n\r\n\t\tif (isSolid && isPushable) {\r\n\t\t\tcanMove = canMove && canMoveToPush(cell, dx, dy);\r\n\t\t}\r\n\t})\r\n\r\n\tif (canMove) {\r\n\t\ttile._x += dx;\r\n\t\ttile._y += dy;\r\n\t}\r\n\r\n\treturn canMove;\r\n}\r\n\r\nconst swap = exports.swap = (arr, newTypes) => { // swap could do multiple\r\n\tif (typeof arr === \"string\") arr = [ arr ];\r\n\tif (typeof newTypes === \"string\") newTypes = [ newTypes ];\r\n\r\n\tconst grid = getGrid();\r\n\r\n\tlet matched = false;\r\n\tlet length = 0;\r\n\r\n\tObject.keys(grid).forEach(k => {\r\n\t\tconst cell = grid[k];\r\n\t\tconst typesInCell = cell.map(tile => tile.type);\r\n\r\n\t\tconst matches = [];\r\n\r\n\t\tarr.forEach(t => {\r\n\t\t\tconst index = typesInCell.indexOf(t);\r\n\t\t\tif (index !== -1 && !matches.includes(index)) {\r\n\t\t\t\tmatches.push(index);\r\n\t\t\t} \r\n\t\t});\r\n\r\n\t\tif (matches.length === arr.length) {\r\n\t\t\tmatches.forEach(i => cell[i].remove());\r\n\t\t\tconst [ x, y ] = k.split(\",\").map(Number);\r\n\r\n\t\t\tnewTypes.forEach(t => addTile(x, y, t));\r\n\r\n\t\t\tmatched = true;\r\n\t\t\tlength++;\r\n\t\t}\r\n\t})\r\n\r\n\treturn length;\r\n}\r\n\r\nclass Tile {\r\n\tconstructor(x, y, type) {\r\n\t\tthis._type = null;\r\n\t\tthis.type = type;\r\n\t\tthis._x = x;\r\n\t\tthis._y = y;\r\n\t\tthis.dx = 0;\r\n\t\tthis.dy = 0;\r\n\t}\r\n\r\n\tset type(t) {\r\n\t\tif (t === \".\") t.remove(); // hmm\r\n\r\n\t\tthis._type = t;\r\n\t\tthis.img = (t in legend) ? legend[t] : defaultSprite;\r\n\t}\r\n\r\n\tget type() {\r\n\t\treturn this._type;\r\n\t}\r\n\r\n\tset x(newX) {\r\n\t\tconst dx = newX - this.x;\r\n\t\tif (canMoveToPush(this, dx, 0)) this.dx = dx;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tget x() {\r\n\t\treturn this._x;\r\n\t}\r\n\r\n\tset y(newY) {\r\n\t\tconst dy = newY - this.y;\r\n\t\tif (canMoveToPush(this, 0, dy)) this.dy = dy;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tget y() {\r\n\t\treturn this._y;\r\n\t}\r\n\r\n\tremove() {\r\n\t\tcurrentLevel = currentLevel.filter(t => t !== this);\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n}\r\n\r\nexports.getTile = type => currentLevel.find(t => t.type === type), // **\r\nexports.getAllTiles = type => currentLevel.filter(t => t.type === type); // **\r\n\r\nconst addTile = exports.addTile = (x, y, type) => { // could take array\r\n\t// if (type === \".\") \r\n\r\n\tconst tile = new Tile(x, y, type);\r\n\tcurrentLevel.push(tile);\r\n\r\n\treturn tile;\r\n};\r\n\r\n\r\nconst dpad = {\r\n  up:    { last: 0, pin: new GPIO(0, INPUT_PULLUP) },\r\n  down:  { last: 0, pin: new GPIO(3, INPUT_PULLUP) },\r\n  left:  { last: 0, pin: new GPIO(2, INPUT_PULLUP) },\r\n  right: { last: 0, pin: new GPIO(1, INPUT_PULLUP) }\r\n};\r\nexports.onInput = function onInput(key, handler) {\r\n\tif (!dpad[key]) throw new Error(\r\n\t\t`expected one of \"up\", \"down\", \"left\", or \"right\", found ${key}`\r\n\t);\r\n\tdpad[key].handler = handler;\r\n}\r\n\r\nconst spi = board.spi(1, {\r\n  sck: 10,\r\n  mosi: 11,\r\n  baudrate: 30000000 // default: 3000000\r\n});\r\n\r\nst7735.setup(spi, { // ST7735R 1.8\"\r\n  width: 128,\r\n  height: 160,\r\n  xstart: 0,\r\n  ystart: 0,\r\n  dc: 16,\r\n  rst: 17,\r\n  cs: 18\r\n});\r\nconst gc = st7735.getContext(\"buffer\");\r\n\r\nclass ImageData {\r\n\tconstructor(pixels, w, h) {\r\n\t\tthis.width = w;\r\n\t\tthis.height = h;\r\n\t\tconst bytes = new Uint8Array(w*h*2);\r\n\t\tfor (let x = 0; x < w; x++)\r\n\t\t\tfor (let y = 0; y < h; y++) {\r\n\t\t\t\tlet i = (y*w + x);\r\n\t\t\t\tconst [r, g, b, a] = pixels.slice(i*4, (i + 1)*4);\r\n\t\t\t\tif (a < 255) continue;\r\n\t\t\t\tconst col = gc.color16(Math.max(b, 5),\r\n\t\t\t\t\t\t\t\t\t   Math.max(g, 5),\r\n\t\t\t\t\t\t\t\t\t   Math.max(r, 5));\r\n\t\t\t\tbytes[i*2+0] = col >> 8;\r\n\t\t\t\tbytes[i*2+1] = col;\r\n\t\t\t}\r\n\t\tthis.data = new Uint16Array(bytes.buffer);\r\n\t}\r\n}\r\n\r\nconst fillImage = (function(x, y, w, h, buf) {\r\n  digitalWrite(this.cs, LOW); // select\r\n  this.cmd(0x2A, [0, x + this.xstart, 0, x + w - 1 + this.xstart]); // column addr set\r\n  this.cmd(0x2B, [0, y + this.ystart, 0, y + h - 1 + this.ystart]); // row addr set\r\n  this.cmd(0x2C); // write to RAM\r\n  this.spi.send(buf);\r\n  digitalWrite(this.cs, HIGH); // deselect\r\n}).bind(st7735);\r\n\r\nconst width = 128, height = 160;\r\nconst screen = new Uint16Array(width * height);\r\nconst { rfill, sprdraw } = global.require(\"native\");\r\nsetInterval(() => {\r\n\tfor (const [name, btn] of Object.entries(dpad)) {\r\n\t\tconst { pin, handler } = btn;\r\n\t\tconst now = pin.read();\r\n\t\tif (handler && btn.last != now && !(btn.last = now))\r\n\t\t\thandler();\r\n\t}\r\n\tafterInputFn();\r\n\r\n\trfill(screen, gc.color16(255, 255, 255), width*height);\r\n\r\n    currentLevel\r\n      .sort((a, b) => zOrder.indexOf(b.type) - zOrder.indexOf(a.type))\r\n      .forEach(tile => {\r\n\r\n\t\tsprdraw(tile.img.data, tile.img.width, tile.img.height,\r\n\t\t        screen, tile.y*16, tile.x*16);\r\n      });\r\n\r\n\tfillImage(0, 0, width, height, new Uint8Array(screen.buffer));\r\n}, 1000/20);\r\n\r\nconst allEqual = arr => arr.every(val => val === arr[0]);\r\nexports.sprite = function sprite(string) { // returns image data\r\n\tconst rows = string.trim().split(\"\\n\").map(x => x.trim());\r\n\tconst rowLengths = rows.map(x => x.length);\r\n\tconst isRect = allEqual(rowLengths);\r\n\tif (!isRect) console.error(\"Level must be rect.\");\r\n\tconst width = rows[0].length;\r\n\tconst height = rows.length;\r\n\tconst data = new Uint8ClampedArray(16*16*4);\r\n\r\n\tconst colors = {\r\n\t\t\"0\": [0, 0, 0, 255],\r\n\t\t\"1\": [255, 255, 255, 255],\r\n\t\t\"r\": [255, 0, 0, 255],\r\n\t\t\"g\": [0, 255, 0, 255],\r\n\t\t\"b\": [0, 0, 255, 255],\r\n\t\t\".\": [0, 0, 0, 0],\r\n\t}\r\n\r\n\tconst chars = string.split(\"\").filter(x => x.match(/\\S/));\r\n\tfor (let i = 0; i < 16*16; i++) {\r\n\t\tconst type = chars[i % (width*height)];\r\n\r\n\t\tif (!(type in colors)) console.error(\"unknown color:\", type);\r\n\r\n\t\tconst [ r, g, b, a ] = colors[type];\r\n\t\tdata[i*4] = r;\r\n\t\tdata[i*4 + 1] = g;\r\n\t\tdata[i*4 + 2] = b;\r\n\t\tdata[i*4 + 3] = a;\r\n\t}\r\n\r\n\tconst result = new ImageData(data, 16, 16);\r\n\r\n\treturn img = result;\r\n};\r\n\r\nconst setScreenSize = exports.setScreenSize = function() {}\r\nexports.setLegend = function setLegend(newLegend) { legend = newLegend; }\r\nexports.setMap = function setMap(string) { // could have background and sprites\r\n\t// check that level is rectangle\r\n\r\n\tclear();\r\n\r\n\tconst rows = string.trim().split(\"\\n\").map(x => x.trim());\r\n\tconst rowLengths = rows.map(x => x.length);\r\n\tconst isRect = allEqual(rowLengths)\r\n\t\tif (!isRect) console.error(\"Level must be rect.\");\r\n\tconst w = rows[0].length;\r\n\tconst h = rows.length;\r\n\t// width = w;\r\n\t// height = h;\r\n\r\n\t// scale the ctx based on aspect ratio of level\r\n\t// tiles should always be square\r\n\t// find max tile width to fit\r\n\r\n\tmaxTileDim = Math.min(width/w, height/h);\r\n\r\n\t// should this adjust screen size?\r\n\tsetScreenSize(w*maxTileDim, h*maxTileDim);\r\n\r\n\tconst chars = string.split(\"\").filter(x => x.match(/\\S/));\r\n\tfor (let i = 0; i < w*h; i++) {\r\n\t\tconst type = chars[i];\r\n\r\n\t\tif (type === \".\") continue;\r\n\r\n\t\tconst x = i%w; \r\n\t\tconst y = Math.floor(i/w); \r\n\t\tconst newTile = new Tile(x, y, type);\r\n\t\tcurrentLevel.push(newTile)\r\n\t}\r\n\r\n\treturn currentLevel;\r\n}\r\n","module.exports = require(\"gpio\");","var graphics = require('graphics');\r\n\r\n/**\r\n * ST7735 class\r\n */\r\nclass ST7735 {\r\n  /**\r\n   * Setup ST7735 for SPI connection\r\n   * @param {SPI} spi\r\n   * @param {Object} options\r\n   *   .width {number=128}\r\n   *   .height {number=128}\r\n   *   .dc {number=-1}\r\n   *   .rst {number=-1}\r\n   *   .cs {number=-1}\r\n   *   .rotation {number=0}\r\n   */\r\n  setup (spi, options) {\r\n    this.spi = spi;\r\n    options = Object.assign({\r\n      width: 128,\r\n      height: 128,\r\n      dc: -1,\r\n      rst: -1,\r\n      cs: -1,\r\n      rotation: 0,\r\n      xstart: 2,\r\n      ystart: 3,\r\n    }, this.init, options);\r\n    this.width = options.width;\r\n    this.height = options.height;\r\n    this.dc = options.dc;\r\n    this.rst = options.rst;\r\n    this.cs = options.cs;\r\n    this.rotation = options.rotation;\r\n    this.xstart = options.xstart;\r\n    this.ystart = options.ystart;\r\n    this.context = null;\r\n    if (this.dc > -1) pinMode(this.dc, OUTPUT);\r\n    if (this.rst > -1) pinMode(this.rst, OUTPUT);\r\n    if (this.cs > -1) pinMode(this.cs, OUTPUT);\r\n    // reset\r\n    digitalWrite(this.cs, HIGH);\r\n    digitalWrite(this.rst, LOW);\r\n    delay(10);\r\n    digitalWrite(this.rst, HIGH);\r\n    delay(10);\r\n    digitalWrite(this.cs, LOW);\r\n    this.initR();\r\n  }\r\n\r\n  initR () {\r\n    this.cmd(0x01);                         // Software reset\r\n    delay(150);\r\n    this.cmd(0x11);                       // Out of sleep mode\r\n    delay(500);\r\n    // 1st commands\r\n    this.cmd(0xB1, [0x01, 0x2C, 0x2D]); // Framerate ctrl (normal mode): rate = fosc/(1x2+40) * (LINE+2C+2D)\r\n    this.cmd(0xB2, [0x01, 0x2C, 0x2D]); // Framerate ctrl (idle mode): rate = fosc/(1x2+40) * (LINE+2C+2D)\r\n    this.cmd(0xB3, [0x01, 0x2C, 0x2D, 0x01, 0x2C, 0x2D]); // Framerate ctrl (partial mode): [Dot inversion,,, Line inversion,,]\r\n    this.cmd(0xB4, [0x07]);             // Display inversion ctrl: [No inversion]\r\n    this.cmd(0xC0, [0xA2, 0x02, 0x84]); // Power ctrl: [-4.6V,, Auto mode]\r\n    this.cmd(0xC1, [0xC5]);             // Power ctrl: [VGH25=2.4C VGSEL=-10 VGH=3 * AVDD]\r\n    this.cmd(0xC2, [0x0A, 0x00]);       // Power ctrl: [Opamp current small, Boost frequency]\r\n    this.cmd(0xC3, [0x8A, 0x2A]);       // Power ctrl: [BCLK/2, opamp current small & medium low]\r\n    this.cmd(0xC4, [0x8A, 0xEE]);       // Power ctrl\r\n    this.cmd(0xC5, [0x0E]);             // Power ctrl\r\n    this.cmd(0x20);                     // Don't invert display\r\n    this.cmd(0x36, [0xC8]);             // Mem access ctrl: [row/col addr bottom-top refresh]\r\n    this.cmd(0x3A, [0x05]);             // Set color mode: [16-bit color]\r\n    // 2nd commands (init based on display types)\r\n    // Init 7735R\r\n    this.cmd(0x2A, [0x00, 0x00, 0x00, this.width - 1]); // Column addr set: XSTART=0, XEND=width\r\n    this.cmd(0x2B, [0x00, 0x00, 0x00, this.height - 1]); // Row addr set: YSTART=0, YEND=height\r\n    // 3rd commands\r\n    this.cmd(0xE0,             // Gamma adjustments (pos. polarity)\r\n      [0x02, 0x1c, 0x07, 0x12,\r\n       0x37, 0x32, 0x29, 0x2d,\r\n       0x29, 0x25, 0x2B, 0x39,\r\n       0x00, 0x01, 0x03, 0x10]); \r\n    this.cmd(0xE1,             // Gamma adjustments (neg. polarity)\r\n      [0x03, 0x1d, 0x07, 0x06,\r\n       0x2E, 0x2C, 0x29, 0x2D,\r\n       0x2E, 0x2E, 0x37, 0x3F,\r\n       0x00, 0x00, 0x02, 0x10]);\r\n    this.cmd(0x13);            // Normal display on\r\n    delay(10);\r\n    this.cmd(0x29);          // Main screen turn on\r\n    delay(100);\r\n    // this.cmd(0x36, [0x40 | 0x80 | 0x08]); // Mem access ctrl: ST77XX_MADCTL_MX | ST77XX_MADCTL_MY | ST7735_MADCTL_BGR;\r\n  }\r\n\r\n  /**\r\n   * Send command\r\n   * @param {number} cmd\r\n   * @param {Array<number>} data\r\n   */\r\n  cmd (cmd, data) {\r\n    digitalWrite(this.dc, LOW); // command\r\n    this.spi.send(new Uint8Array([cmd]));\r\n    digitalWrite(this.dc, HIGH); // data\r\n    if (data) this.spi.send(new Uint8Array(data));\r\n  }\r\n  \r\n  /**\r\n   * Get a graphic context\r\n   * @param {string} type Type of graphic context.\r\n   *     'buffer' or 'callback'. Default is 'callback'\r\n   */\r\n  getContext (type) {\r\n\tif (!this.context) {\r\n      if (type === 'buffer') {\r\n        this.context = new graphics.BufferedGraphicsContext(this.width, this.height, {\r\n          rotation: this.rotation,\r\n          bpp: 16,\r\n          display: (buffer) => {\r\n            digitalWrite(this.cs, LOW); // select\r\n            this.cmd(0x2A, [0, this.xstart, 0, this.width - 1 + this.xstart]); // column addr set\r\n            this.cmd(0x2B, [0, this.ystart, 0, this.height - 1 + this.ystart]); // row addr set\r\n            this.cmd(0x2C, buffer); // write to RAM\r\n            digitalWrite(this.cs, HIGH); // deselect\r\n          }\r\n        });\r\n      } else { // 'callback'\r\n        this.context = new graphics.GraphicsContext(this.width, this.height, {\r\n          rotation: this.rotation,\r\n          setPixel: (x, y, c) => {\r\n            digitalWrite(this.cs, LOW); // select\r\n            this.cmd(0x2A, [0, x + this.xstart, 0, x + 1 + this.xstart]); // column addr set\r\n            this.cmd(0x2B, [0, y + this.ystart, 0, y + 1 + this.ystart]); // row addr set\r\n            this.cmd(0x2C, [c>>8, c]); // write to RAM\r\n            digitalWrite(this.cs, HIGH); // deselect\r\n          },\r\n          fillRect: (x, y, w, h, c) => {\r\n            digitalWrite(this.cs, LOW); // select\r\n            this.cmd(0x2A, [0, x + this.xstart, 0, x + w - 1 + this.xstart]); // column addr set\r\n            this.cmd(0x2B, [0, y + this.ystart, 0, y + h - 1 + this.ystart]); // row addr set\r\n            this.cmd(0x2C); // write to RAM\r\n            this.spi.send(new Uint8Array([c>>8, c]), 5000, w * h);\r\n            digitalWrite(this.cs, HIGH); // deselect\r\n          }\r\n        });\r\n      }\r\n    }\r\n    return this.context;\r\n  }\r\n}\r\n\r\nexports.ST7735 = ST7735;\r\n","module.exports = require(\"graphics\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// import { init } from \"../engine/gamelab_functions.js\";\r\n\r\n// const canvas = document.querySelector(\".minimal\");\r\n\r\nconst {\r\n  setScreenSize,\r\n  setLegend, \r\n  setMap, \r\n  getCell,\r\n  addTile, \r\n  clearTile, \r\n  setSolids,\r\n  setPushables, \r\n  replace, \r\n  onInput,\r\n  afterInput, \r\n  getGrid,\r\n  getAllTiles, \r\n  clear, \r\n  setZOrder, \r\n  sprite,\r\n  swap,\r\n  match,\r\n  setBackground,\r\n  getTile\r\n} = require(\"./engine.js\");\r\n\r\nsetLegend({\r\n  \"d\": sprite(`\r\n................\r\n................\r\n.......0000.....\r\n.......0ggg0....\r\n......0ggggg0...\r\n......0gggbgr...\r\n......0gggggrr..\r\n.......0gggg0...\r\n..00000ggggg0...\r\n..0ggggggggg0...\r\n..0ggggggggg0...\r\n...0ggggggg0....\r\n....0ggggg00....\r\n.....00000......\r\n......00.00.....\r\n................\r\n\r\n    `),\r\n  \"w\": sprite(\"b\"),\r\n  \"b\": sprite(\"0\"),\r\n  \"r\": sprite(`\r\n................\r\n................\r\n................\r\n......rrrrr.....\r\n.....rrrrrrr....\r\n....rrrrrrrrr...\r\n....rrrrrrrrr...\r\n....rrrrrrrrr...\r\n....rrrrrrrrr...\r\n....rrrrrrrrr...\r\n....rrrrrrrrr...\r\n.....rrrrrrr....\r\n......rrrrr.....\r\n................\r\n................\r\n................\r\n    `),\r\n    \"g\": sprite(`\r\n................\r\n................\r\n................\r\n......ggggg.....\r\n.....ggggggg....\r\n....ggggggggg...\r\n....ggggggggg...\r\n....ggggggggg...\r\n....ggggggggg...\r\n....ggggggggg...\r\n....ggggggggg...\r\n.....ggggggg....\r\n......ggggg.....\r\n................\r\n................\r\n................\r\n    `)\r\n})\r\n\r\n// setBackground(\"w\")\r\n\r\nconst map = `\r\nbbbbbbbbbb\r\nbd.b.....b\r\nb..b.b...b\r\nb..b.b...b\r\nb....b..rb\r\nbbbbbbbbbb\r\n`\r\n\r\nsetSolids([\"b\", \"d\"])\r\n\r\nsetZOrder([\"d\", \"g\", \"r\"])\r\n\r\nsetMap(map)\r\n\r\nonInput(\"up\", _ => {\r\n  getTile(\"d\").y -= 1;\r\n})\r\n\r\nonInput(\"down\", _ => {\r\n  getTile(\"d\").y += 1;\r\n})\r\n\r\nonInput(\"left\", _ => {\r\n  getTile(\"d\").x -= 1;\r\n})\r\n\r\nonInput(\"right\", _ => {\r\n  getTile(\"d\").x += 1;\r\n})\r\n\r\n/*\r\nonRight(() => {\r\n  getTile(\"d\").x += 1;\r\n})\r\n\r\n\r\n\r\nwindow.addEventListener('resize',resize);\r\nframe.ondragover = allowDrop;\r\nframe.ondrop = handleDropFile;\r\n\r\nfunction handleRight() {\r\n  getTile(\"d\").x += 1;\r\n}\r\n\r\nonRight = handleRight;\r\n\r\nonRight(handleRight);\r\n\r\nonInput(\"right\", handleRight);\r\n\r\nonInput({\r\n  right: handleRight,\r\n  left: handleLeft,\r\n  up: handleUp,\r\n  down: handleDown\r\n})\r\n*/\r\n\r\nafterInput(_ => {\r\n\r\n  const swapped = swap([\"d\", \"r\"], [\"d\", \"g\"]);\r\n\r\n  if (swapped) {\r\n    console.log(\"you win\");\r\n  }\r\n\r\n})\r\n\r\n\r\n"],"names":[],"sourceRoot":""}